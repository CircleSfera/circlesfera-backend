// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
  engineType = "library"
  previewFeatures = []
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Account Status
  isActive  Boolean  @default(true)
  deletedAt DateTime?

  profile       Profile?
  posts         Post[]
  stories       Story[]
  comments      Comment[]
  likes         Like[]
  followers     Follow[]       @relation("UserFollowing")
  following     Follow[]       @relation("UserFollowers")
  notifications Notification[] @relation("NotificationRecipient")
  sentNotifications Notification[] @relation("NotificationSender")
  refreshTokens RefreshToken[]
  
  // Chat relations
  participants Participant[]
  messages     Message[]
  messageReactions MessageReaction[] // New: User reactions to messages

  // Block relations
  blockedBy Block[]  @relation("BlockedBy")
  blocking  Block[]  @relation("Blocking")
  
  // Bookmarks
  bookmarks   Bookmark[]
  collections Collection[]

  // Highlights
  highlights Highlight[]

  // Passkeys for WebAuthn
  passkeys   Passkey[]
  currentChallenge String? // Temporary storage for registration/auth challenge

  // Close Friends
  closeFriends CloseFriend[]

  // Story Views
  storyViews StoryView[]
  
  // Story Reactions
  storyReactions StoryReaction[]
  
  // Tagged in posts
  taggedPosts PostTag[]

  // Reports
  reports     Report[]

  // Search History
  searchHistory SearchHistory[]

  // Activity Status
  isOnline    Boolean   @default(false)
  lastSeenAt  DateTime?

  role        Role      @default(USER)
  
  // Verification and Reset Tokens
  emailVerified     DateTime?
  verificationToken String?   @unique
  resetToken        String?   @unique
  resetTokenExpires DateTime?

  @@index([isOnline])
  @@index([verificationToken])
  @@index([resetToken])
  @@map("users")
}

enum Role {
  USER
  ADMIN
}

enum PostType {
  POST
  FRAME
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("refresh_tokens")
}

model Profile {
  id        String   @id @default(uuid())
  userId    String   @unique
  username  String   @unique
  fullName  String?
  bio       String?
  avatar    String?
  website   String?
  location  String?
  isPrivate Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([username])
  @@map("profiles")
}

model Post {
  id        String   @id @default(uuid())
  userId    String
  caption   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  media    PostMedia[] // New: Support for multiple media files
  comments Comment[]
  likes    Like[]
  bookmarks Bookmark[]
  hashtags PostHashtag[]
  notifications Notification[]
  embedding PostEmbedding? // New: AI Embedding support
  
  // New: Sharing in Chat
  sharedInMessages Message[] @relation("SharedPosts")
  
  tags      PostTag[] // New: Tagged users
  
  location        String?
  hideLikes       Boolean  @default(false)
  turnOffComments Boolean  @default(false)

  type      PostType @default(POST)

  audioId   String?
  audio     Audio?   @relation(fields: [audioId], references: [id], onDelete: SetNull)

  @@index([userId, type, createdAt])
  @@index([userId])
  @@index([createdAt])
  @@index([type])
  @@map("posts")
}

model PostTag {
  postId    String
  userId    String
  x         Float?   // Optional: X coordinate (0-1)
  y         Float?   // Optional: Y coordinate (0-1)
  createdAt DateTime @default(now())

  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([userId])
  @@map("post_tags")
}

model Bookmark {
  id        String   @id @default(uuid())
  userId    String
  postId    String
  createdAt DateTime @default(now())
  
  collectionId String?
  collection   Collection? @relation(fields: [collectionId], references: [id], onDelete: SetNull)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId])
  @@index([userId, createdAt])
  @@index([userId])
  @@index([postId])
  @@index([collectionId])
  @@map("bookmarks")
}

model Collection {
  id        String   @id @default(uuid())
  userId    String
  name      String
  coverUrl  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookmarks Bookmark[]

  @@index([userId])
  @@map("collections")
}

model PostMedia {
  id        String   @id @default(uuid())
  postId    String
  url       String
  type      String   @default("image") // "image" | "video"
  order     Int      @default(0)       // For carousel ordering
  filter    String?  // Store filter ID (e.g. "sepia", "clarendon")
  altText   String?  // Accessibility text
  createdAt DateTime @default(now())
  
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  
  @@index([postId])
  @@map("post_media")
}

model Story {
  id        String   @id @default(uuid())
  userId    String
  mediaUrl  String
  mediaType String   @default("image") // image or video
  expiresAt DateTime
  createdAt DateTime @default(now())

  // New: Close Friends support
  isCloseFriendsOnly Boolean @default(false)

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  audioId   String?
  audio     Audio?   @relation(fields: [audioId], references: [id], onDelete: SetNull)

  // Relation to highlights
  highlightStories HighlightStory[]
  
  // Views
  views StoryView[]

  // New: Story Reactions
  reactions StoryReaction[]

  @@index([userId, createdAt])
  @@index([userId])
  @@index([expiresAt])
  @@index([createdAt])
  @@map("stories")
}

model StoryView {
  id        String   @id @default(uuid())
  storyId   String
  viewerId  String
  createdAt DateTime @default(now())

  story     Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  viewer    User     @relation(fields: [viewerId], references: [id], onDelete: Cascade)

  @@unique([storyId, viewerId]) // One view per user per story
  @@index([storyId])
  @@map("story_views")
}

model StoryReaction {
  id        String   @id @default(uuid())
  storyId   String
  userId    String
  reaction  String   // e.g. "‚ù§Ô∏è", "üî•", "üòÇ"
  createdAt DateTime @default(now())

  story     Story    @relation(fields: [storyId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([storyId, userId])
  @@index([storyId])
  @@map("story_reactions")
}

model Highlight {
  id        String   @id @default(uuid())
  userId    String
  title     String
  coverUrl  String?  // Optional custom cover, otherwise use first story
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  stories HighlightStory[]

  @@index([userId])
  @@map("highlights")
}

model HighlightStory {
  id          String   @id @default(uuid())
  highlightId String
  storyId     String
  createdAt   DateTime @default(now())

  highlight Highlight @relation(fields: [highlightId], references: [id], onDelete: Cascade)
  story     Story     @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@unique([highlightId, storyId])
  @@map("highlight_stories")
}

model CloseFriend {
  id        String   @id @default(uuid())
  userId    String
  friendId  String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  // We don't necessarily need a strict relation to the friend User model if we just store ID, 
  // but let's keep it simple for now and just store the ID or relation if needed. 
  // Ideally, it's a relation to User.
  // dependent on implementation, but let's assume friendId is a valid userId.
  
  @@unique([userId, friendId])
  @@index([userId])
  @@map("close_friends")
}

model Comment {
  id        String   @id @default(uuid())
  postId    String
  userId    String
  content   String
  mediaUrl  String?
  mediaType String?   // "image", "video", "file"
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Self-relation for nested comments
  parentId  String?
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[] @relation("CommentReplies")

  @@index([postId, createdAt])
  @@index([postId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@map("comments")
}

model Like {
  id        String   @id @default(uuid())
  postId    String
  userId    String
  createdAt DateTime @default(now())

  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId])
  @@index([userId, createdAt])
  @@index([postId])
  @@index([userId])
  @@map("likes")
}

model Follow {
  id          String   @id @default(uuid())
  followerId  String
  followingId String
  status      FollowStatus @default(ACCEPTED)
  createdAt   DateTime @default(now())

  follower  User @relation("UserFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowing", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId, status])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model Block {
  id        String   @id @default(uuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker   User     @relation("Blocking", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("BlockedBy", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@map("blocks")
}

enum FollowStatus {
  PENDING
  ACCEPTED
}

model Notification {
  id         String   @id @default(uuid())
  recipientId String
  senderId   String?
  type       String   // like, comment, follow
  content    String
  read       Boolean  @default(false)
  
  postId     String?
  post       Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)

  createdAt  DateTime @default(now())

  recipient User  @relation("NotificationRecipient", fields: [recipientId], references: [id], onDelete: Cascade)
  sender    User? @relation("NotificationSender", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([recipientId, type, createdAt])
  @@index([recipientId, read, createdAt])
  @@index([recipientId])
  @@index([createdAt])
  @@map("notifications")
}

model Conversation {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name      String?
  isGroup   Boolean  @default(false)

  messages     Message[]
  participants Participant[]

  @@map("conversations")
}

model Participant {
  id             String   @id @default(uuid())
  conversationId String
  userId         String
  lastReadAt     DateTime @default(now()) // New: For "Seen" status
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@map("participants")
}

model Message {
  id             String   @id @default(uuid())
  conversationId String
  senderId       String
  content        String
  mediaUrl       String?  // New: Image/File URL
  mediaType      String?  // New: "image", "video", "file"
  
  // New: Post Sharing
  postId         String?
  post           Post?     @relation("SharedPosts", fields: [postId], references: [id])
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @default(now()) @updatedAt // Added updatedAt for replies editing logic if needed

  // New: Reply support
  replyToId      String?
  replyTo        Message?  @relation("MessageReplies", fields: [replyToId], references: [id])
  replies        Message[] @relation("MessageReplies")

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  
  reactions    MessageReaction[]

  @@index([conversationId])
  @@index([replyToId])
  @@index([createdAt])
  @@map("messages")
}

model MessageReaction {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  reaction  String   // e.g. "‚ù§Ô∏è", "üëç"
  createdAt DateTime @default(now())

  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId])
  @@index([messageId])
  @@map("message_reactions")
}

model Hashtag {
  id        String   @id @default(uuid())
  tag       String   @unique
  postCount Int      @default(0)
  createdAt DateTime @default(now())

  posts PostHashtag[]
  
  @@index([postCount(sort: Desc)])
  @@map("hashtags")
}

model PostHashtag {
  postId    String
  hashtagId String
  createdAt DateTime @default(now())

  post    Post    @relation(fields: [postId], references: [id], onDelete: Cascade)
  hashtag Hashtag @relation(fields: [hashtagId], references: [id], onDelete: Cascade)

  @@id([postId, hashtagId])
  @@index([hashtagId])
  @@map("post_hashtags")
}

model PostEmbedding {
  postId String @id
  vector Json? // Stores the high-dimensional vector for semantic search
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@map("post_embeddings")
}

model Passkey {
  id           String   @id @default(uuid())
  userId       String
  credentialID String   @unique
  publicKey    Bytes
  counter      BigInt
  transports   String[] @default([])
  createdAt    DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("passkeys")
}

// Content Reporting
model Report {
  id         String   @id @default(uuid())
  reporterId String
  reason     String   // "spam", "harassment", "inappropriate", "other"
  details    String?
  status     String   @default("pending") // "pending", "reviewed", "resolved"
  
  // Target type
  targetType String   // "user" or "post"
  targetId   String
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  reporter   User     @relation(fields: [reporterId], references: [id], onDelete: Cascade)
  
  @@index([reporterId])
  @@index([targetType, targetId])
  @@map("reports")
}

// Search History
model SearchHistory {
  id        String   @id @default(uuid())
  userId    String
  query     String
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@map("search_history")
}

model Audio {
  id           String   @id @default(uuid())
  title        String
  artist       String
  url          String
  thumbnailUrl String?
  duration     Int      // in seconds
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  posts        Post[]
  stories      Story[]

  @@map("audio_tracks")
}
